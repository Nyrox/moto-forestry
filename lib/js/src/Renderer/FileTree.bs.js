// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Vdom = require("bucklescript-tea/lib/js/src-ocaml/vdom.js");
var Path = require("path");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Utils = require("./Utils.bs.js");
var $$Option = require("./Option.bs.js");
var Tea_cmd = require("bucklescript-tea/lib/js/src-ocaml/tea_cmd.js");
var Tea_html = require("bucklescript-tea/lib/js/src-ocaml/tea_html.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var ContextMenu = require("./ContextMenu.bs.js");
var Tea_promise = require("bucklescript-tea/lib/js/src-ocaml/tea_promise.js");

function absolute(path) {
  return {
          repr: path
        };
}

function resolve(path) {
  return {
          repr: Path.resolve(path, ".")
        };
}

function basename(file) {
  return Path.basename(file.repr);
}

function dirname(file) {
  return Path.dirname(file.repr);
}

function asString(file) {
  return file.repr;
}

function extend(path, segment) {
  return {
          repr: Path.resolve(path.repr, segment)
        };
}

var Path$1 = {
  absolute: absolute,
  resolve: resolve,
  basename: basename,
  dirname: dirname,
  asString: asString,
  extend: extend
};

var readdir = (function (path) {
    let __impl = require("util").promisify(require("fs").readdir)
    return __impl(path)
});

let __impl_stat = require("util").promisify(require("fs").stat);
;

var dirtype_r = (async function dirtype(path) {
    let __stat = await __impl_stat(path)
    if (__stat.isDirectory()) {
        return "directory"
    }
    else if (__stat.isFile()) {
        return "file"
    }
    else {
        return "other"
    }
});

var DirType = { };

function getDirtype(path) {
  return Curry._1(dirtype_r, path).then((function (s) {
                return Promise.resolve(s === "directory" ? /* Directory */0 : (
                              s === "file" ? /* File */1 : /* Other */2
                            ));
              }));
}

function mapFileToStats(f) {
  return getDirtype(f).then((function (stats) {
                return Promise.resolve(stats);
              }));
}

function $great$great(f, g, a) {
  return Curry._1(g, Curry._1(f, a));
}

function $less$less(f, g, a) {
  return Curry._1(f, Curry._1(g, a));
}

function choose(l) {
  return List.concat(List.map((function (x) {
                    if (x !== undefined) {
                      return /* :: */[
                              Caml_option.valFromOption(x),
                              /* [] */0
                            ];
                    } else {
                      return /* [] */0;
                    }
                  }), l));
}

function let_(a, b) {
  return a.then(Curry.__1(b));
}

var Async = {
  let_: let_
};

function buildTree(path) {
  var a = readdir(path.repr);
  return a.then((function (f) {
                var a = Promise.all($$Array.map((function (file) {
                            var path$1 = extend(path, file);
                            var a = mapFileToStats(path$1.repr);
                            return a.then((function (stat) {
                                          return Promise.resolve(/* tuple */[
                                                      path$1,
                                                      stat
                                                    ]);
                                        }));
                          }), f));
                return a.then((function (fileStats) {
                              var a = Promise.all($$Array.map((function (param) {
                                          var path = param[0];
                                          switch (param[1]) {
                                            case /* Directory */0 :
                                                var a = buildTree(path);
                                                return a.then((function (tree) {
                                                              return Promise.resolve(tree);
                                                            }));
                                            case /* File */1 :
                                                return Promise.resolve(/* File */Block.__(0, [path]));
                                            case /* Other */2 :
                                                return Promise.resolve(undefined);
                                            
                                          }
                                        }), fileStats));
                              var a$1 = a.then((function (nodes) {
                                      return Promise.resolve(choose($$Array.to_list(nodes)));
                                    }));
                              return a$1.then((function (childNodes) {
                                            return Promise.resolve(/* Directory */Block.__(1, [/* tuple */[
                                                            path,
                                                            childNodes,
                                                            false
                                                          ]]));
                                          }));
                            }));
              }));
}

function init(path) {
  var tree = /* Directory */Block.__(1, [/* tuple */[
        {
          repr: "loading"
        },
        /* [] */0,
        false
      ]]);
  var baseModel = {
    base_path: path,
    tree: tree,
    contextMenu: undefined
  };
  return /* tuple */[
          baseModel,
          Tea_promise.result(buildTree(path), (function (v) {
                  var tmp;
                  if (v.tag) {
                    console.log(v[0]);
                    tmp = /* Directory */Block.__(1, [/* tuple */[
                          path,
                          /* [] */0,
                          false
                        ]]);
                  } else {
                    tmp = v[0];
                  }
                  return /* RebuiltTree */Block.__(0, [tmp]);
                }))
        ];
}

var treeIteration = {
  contents: 0
};

function update(model, msg) {
  treeIteration.contents = treeIteration.contents + 1 | 0;
  switch (msg.tag | 0) {
    case /* RebuiltTree */0 :
        return /* tuple */[
                {
                  base_path: model.base_path,
                  tree: msg[0],
                  contextMenu: model.contextMenu
                },
                Tea_cmd.none,
                /* DoNothing */0
              ];
    case /* CreateContextMenu */1 :
        var m = msg[0];
        console.log(m);
        return /* tuple */[
                {
                  base_path: model.base_path,
                  tree: model.tree,
                  contextMenu: m
                },
                Tea_cmd.none,
                /* DoNothing */0
              ];
    case /* DestroyContextMenu */2 :
        var msg$1 = msg[0];
        var match = msg$1 !== undefined ? update(model, msg$1) : /* tuple */[
            model,
            Tea_cmd.none,
            /* DoNothing */0
          ];
        var _model = match[0];
        return /* tuple */[
                {
                  base_path: _model.base_path,
                  tree: _model.tree,
                  contextMenu: undefined
                },
                match[1],
                match[2]
              ];
    case /* DoubleClickFile */3 :
        return /* tuple */[
                model,
                Tea_cmd.none,
                /* OpenFile */[msg[0]]
              ];
    
  }
}

function dirEntry(replace, param) {
  var hidden = param[2];
  var files = param[1];
  var name = param[0];
  var contextMenu_000 = /* tuple */[
    "Open File",
    /* DestroyContextMenu */Block.__(2, [/* RebuiltTree */Block.__(0, [Curry._1(replace, /* Directory */Block.__(1, [/* tuple */[
                      name,
                      files,
                      !hidden
                    ]]))])])
  ];
  var contextMenu = /* :: */[
    contextMenu_000,
    /* [] */0
  ];
  var srcString = Utils.getStaticAssetPath(hidden ? "icons/directory_open.svg" : "icons/directory.svg");
  var icon = Tea_html.img(undefined, undefined, /* :: */[
        Tea_html.src(srcString),
        /* [] */0
      ], /* [] */0);
  return ContextMenu.contextMenuContainer(/* CreateContextMenu */Block.__(1, [contextMenu]), String(treeIteration.contents), (function (eta) {
                return Curry._3(Tea_html.li, undefined, undefined, eta);
              }), /* :: */[
              Tea_html.onClick(/* RebuiltTree */Block.__(0, [Curry._1(replace, /* Directory */Block.__(1, [/* tuple */[
                                name,
                                files,
                                !hidden
                              ]]))])),
              /* :: */[
                Tea_html.class$prime(hidden ? "directory hidden" : "directory"),
                /* [] */0
              ]
            ], /* :: */[
              icon,
              /* :: */[
                Tea_html.text(Path.basename(name.repr)),
                /* [] */0
              ]
            ]);
}

function treeNode(replace, node) {
  if (node.tag) {
    var match = node[0];
    var hidden = match[2];
    var files = match[1];
    var name = match[0];
    var childNodes = List.mapi((function (i, outerNode) {
            return treeNode((function (replaceWith) {
                          return Curry._1(replace, /* Directory */Block.__(1, [/* tuple */[
                                          name,
                                          List.mapi((function (j, node) {
                                                  if (i === j) {
                                                    return replaceWith;
                                                  } else {
                                                    return node;
                                                  }
                                                }), files),
                                          hidden
                                        ]]));
                        }), outerNode);
          }), files);
    return /* :: */[
            dirEntry(replace, /* tuple */[
                  name,
                  files,
                  hidden
                ]),
            /* :: */[
              Tea_html.ul(undefined, undefined, /* :: */[
                    Tea_html.class$prime("file-list"),
                    /* [] */0
                  ], List.flatten(childNodes)),
              /* [] */0
            ]
          ];
  }
  var name$1 = node[0];
  return /* :: */[
          Tea_html.li(undefined, undefined, /* :: */[
                Tea_html.onDoubleClick(/* DoubleClickFile */Block.__(3, [name$1])),
                /* [] */0
              ], /* :: */[
                Tea_html.text(Path.basename(name$1.repr)),
                /* [] */0
              ]),
          /* [] */0
        ];
}

function view(model) {
  var ft = Tea_html.ul(undefined, undefined, /* :: */[
        Tea_html.class$prime("file-tree"),
        /* [] */0
      ], treeNode((function (v) {
              return v;
            }), model.tree));
  return /* tuple */[
          ft,
          /* :: */[
            $$Option.orDefault(Vdom.noNode, $$Option.map(ContextMenu.viewMenuPopup, model.contextMenu)),
            /* [] */0
          ]
        ];
}

exports.Path = Path$1;
exports.readdir = readdir;
exports.dirtype_r = dirtype_r;
exports.DirType = DirType;
exports.getDirtype = getDirtype;
exports.mapFileToStats = mapFileToStats;
exports.$great$great = $great$great;
exports.$less$less = $less$less;
exports.choose = choose;
exports.Async = Async;
exports.buildTree = buildTree;
exports.init = init;
exports.treeIteration = treeIteration;
exports.update = update;
exports.dirEntry = dirEntry;
exports.treeNode = treeNode;
exports.view = view;
/*  Not a pure module */
