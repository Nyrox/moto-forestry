// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Utils = require("../Utils.bs.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Json_encode = require("@glennsl/bs-json/lib/js/src/Json_encode.bs.js");

function mesh(param_0) {
  return /* Mesh */[param_0];
}

function createEmpty(name) {
  return {
          name: name,
          vertexInput: /* NoData */0
        };
}

var Pass = {
  createEmpty: createEmpty
};

function createPass(project, passName) {
  return {
          passes: /* :: */[
            {
              name: passName,
              vertexInput: /* NoData */0
            },
            project.passes
          ]
        };
}

var Project = {
  createPass: createPass
};

function createProject(param) {
  return {
          passes: /* [] */0
        };
}

function vertexInput(json) {
  return Json_decode.andThen((function (param) {
                switch (param) {
                  case "mesh" :
                      return (function (param) {
                          return Json_decode.map((function (s) {
                                        return /* Mesh */[Utils.Path.absolute(s)];
                                      }), (function (param) {
                                        return Json_decode.field("path", Json_decode.string, param);
                                      }), param);
                        });
                  case "nodata" :
                      return (function (param) {
                          return /* NoData */0;
                        });
                  default:
                    return Pervasives.failwith("Unexpected vertexInput variant");
                }
              }), (function (param) {
                return Json_decode.field("type", Json_decode.string, param);
              }), json);
}

function pass(json) {
  return {
          name: Json_decode.field("name", Json_decode.string, json),
          vertexInput: Json_decode.field("vertexInput", vertexInput, json)
        };
}

function project(json) {
  return {
          passes: Json_decode.field("passes", (function (param) {
                  return Json_decode.list(pass, param);
                }), json)
        };
}

var Decode = {
  vertexInput: vertexInput,
  pass: pass,
  project: project
};

function vertexInput$1(v) {
  return Json_encode.object_(v ? /* :: */[
                /* tuple */[
                  "type",
                  "mesh"
                ],
                /* :: */[
                  /* tuple */[
                    "mesh",
                    Utils.Path.asString(v[0])
                  ],
                  /* [] */0
                ]
              ] : /* :: */[
                /* tuple */[
                  "type",
                  "nodata"
                ],
                /* [] */0
              ]);
}

function pass$1(p) {
  return Json_encode.object_(/* :: */[
              /* tuple */[
                "name",
                p.name
              ],
              /* :: */[
                /* tuple */[
                  "vertexInput",
                  vertexInput$1(p.vertexInput)
                ],
                /* [] */0
              ]
            ]);
}

function project$1(p) {
  return Json_encode.object_(/* :: */[
              /* tuple */[
                "passes",
                Json_encode.list(pass$1, p.passes)
              ],
              /* [] */0
            ]);
}

var Encode = {
  vertexInput: vertexInput$1,
  pass: pass$1,
  project: project$1
};

var noData = /* NoData */0;

exports.mesh = mesh;
exports.noData = noData;
exports.Pass = Pass;
exports.Project = Project;
exports.createProject = createProject;
exports.Decode = Decode;
exports.Encode = Encode;
/* Utils Not a pure module */
